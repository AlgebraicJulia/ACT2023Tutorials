---
title: Solutions to Exercises
---

## Part 1

:::{.rmenv title="Exercise (Installation)"}
Follow the [quick start](quickstart) instructions to install Julia, a code editor, and the git version control system.
:::

:::{.solenv}
If you're stuck on setup, please ask an instructor or TA for help!
:::

:::{.rmenv title="Exercise (Hello World)"}
Get Julia to print "Hello World".
:::

:::{.solenv}
Output text with the `println` function.

```{julia}
println("Hello World!")
```

String concatentation in Julia uses the `*` symbol.

```{julia}
println("Hello" * " " * "World!")
```

Print everything in a vector by using broadcasting. To broadcast, append `.` to your function, and pass it something you can iterate over (like a vector). Or, use `map` or `foreach`.

```{julia}
# Both of these return a vector of `nothing`s:

# println.(["Hello", "World!"])
# map(println, ["Hello", "World!"])

# This one produces side effects only:
foreach(println, ["Hello", "World!"])
```

Perform string interpolation using `$`.

```{julia}
favorite_library = "AlgebraicDynamics.jl"

println("My favorite AlgebraicJulia package is $(favorite_library)!")
```
:::

:::{.rmenv title="Exercise (Package management)"}
Install a Julia package, such as `Catlab` or `AlgebraicDynamics`, using the [Julia package manager](https://docs.julialang.org/en/v1/stdlib/Pkg/).
:::

:::{.solenv}
From a Julia REPL, enter the package manager by typing `]`. Create a new project, which will organize the packages you're using for this workshop, by typing
`pkg> activate .`
Next, add Catlab to your project by typing
`pkg> add Catlab`
You should see a bunch of stuff happening, including precompilation of the Catlab code.

When that's finished, hit backspace to get out of the package manager and type
```julia
using Catlab
```
to load Catlab into your REPL session. To make sure it worked right, try something like
```julia
g = path_graph(Graph, 7)
```
to produce your first graph in Catlab!
:::


:::{.rmenv title="Exercise (Sharing is caring)"}
Fork and clone the [ACT2023Tutorial](https://github.com/AlgebraicJulia/ACT2023Tutorial) repository, make a change, commit it, and create a pull request.
:::

:::{.solenv}
1. Log into [github.com](https://github.com)
2. Navigate to [github.com/AlgebraicJulia/ACT2023Tutorials](https://github.com/AlgebraicJulia/ACT2023Tutorials)
3. By the top right of the page there click the "Fork" button to the left of the "Star" button.
4. On the next page click "Create fork", this will create a copy of the repository on your own GitHub account
5. Clone your fork (replacing `<user_name>` with your own GitHub username)
   ```sh
   git clone https://github.com/<user_name>/ACT2023Tutorials.git
   ```
6. Navigate into the solutions folder and create a new directory with your name (replacing `<your_name>` with your own name)
   ```sh
   cd ACT2023Tutorials/solutions
   mkdir <your_name>
   ```
7. Put some code in there!
   ```sh
   echo "print('Hello, World!')" > hello_world.jl
   ```
8. Stage, commit, and push your changes
   ```sh
   git add hello_world.jl
   git commit -m "Adding solutions for <your_name>"
   git push
   ```
9. Navigate to your fork on GitHub (replacing `<user_name>` with your GitHub username): `https://github.com/<user_name>/ACT2023Tutorials`
10. Click the "Pull requests" tab across the top of the page and click the "New pull request". This will automatically create a new pull request on the original repository from your fork
11. Click "Create pull request"
12. Put a short title and description and click "Create pull request"
:::

:::{.rmenv title="Exercise (Finite sets)"}
Write a function that computes the product of two finite sets, along with the projection maps out.
:::

:::{.solenv}
We'll use the types `FinSet` and `FinFunction` exported by Catlab, which are similar to but more general than those in the problem statement.

```{julia}
#| output: false
using Catlab

function product_projections(A::FinSet{Int}, B::FinSet{Int})
  m, n = length(A), length(B)
  AB = FinSet(m*n)
  # In this calculation, `÷` (short for `div` function) is truncating integer
  # division and `%` (short for `mod` function) is the modulus.
  # Notice that we're using the skeleton of FinSet with sets `1:n` but the
  # calculation below is most natural for sets `0:(n-1)`.
  πA = FinFunction(i -> (i-1) ÷ n + 1, AB, A)
  πB = FinFunction(i -> (i-1) % n + 1, AB, B)
  (πA, πB)
end
```

An example:

```{julia}
using Test

π₁, π₂ = product_projections(FinSet(3), FinSet(4))
@test dom(π₁) == dom(π₂) == FinSet(12)
@test collect(π₁) == [1,1,1,1, 2,2,2,2, 3,3,3,3]
@test collect(π₂) == [1,2,3,4, 1,2,3,4, 1,2,3,4]
```
:::

:::{.rmenv title="Exercise (Graphs)"}
Implement a graph data structure in Catlab either (a) using Catlab's support for C-sets (`@acset_type`) or (b) more directly, using finite sets (`FinSet`) and functions (`FinFunction`).
:::

:::{.solenv}

a. Graphs as C-sets:

   ```{julia}
   using Catlab

   @present SchGph(FreeSchema) begin
      V::Ob
      E::Ob
      src::Hom(E,V)
      tgt::Hom(E,V)
   end

   # Index the `src` and `tgt` functions for fast lookups of inverse images
   # using the `incident` function.
   @acset_type Gph(SchGph, index=[:src,:tgt])

   # An example graph
   g = @acset Gph begin
     V = 3
     E = 2
     src = [1,1]
     tgt = [2,1]
   end
   ```
   
   We use the name `Gph` to avoid a name conflict with Catlab's exported type
   `Graph`, but `Graph` is defined in Catlab in exactly the same way!
   
   The exported `Graph` type includes support for visualization using
   [Graphviz](https://graphviz.org/), which we can use to see what the above
   graph looks like:
   
   ```{julia}
   g = @acset Graph begin
     V = 3
     E = 2
     src = [1,1]
     tgt = [2,1]
   end
   
   to_graphviz(g, node_labels=true)
   ```
   
b. Using finite sets and functions:

   ```{julia}
   #| output: false
   # Catlab exports these generic functions. We import them explicitly so that
   # we can add new methods to them.
   import Catlab: src, tgt, vertices, edges
   
   struct MyGraph
     # We don't need fields for `E` and `V` since these are the domain and
     # codomain of `src` and `tgt`.
     src::FinFunction
     tgt::FinFunction

     function MyGraph(src::FinFunction, tgt::FinFunction)
       dom(src) == dom(tgt) || error("Source and target must have same domain")
       codom(src) == codom(tgt) || error("Source and target must have same codomain")
       new(src, tgt)
     end
   end

   # A few accessor functions. Our users shouldn't need to know the internal
   # layout of the fields in the struct!
   src(g::MyGraph) = g.src
   tgt(g::MyGraph) = g.tgt
   vertices(g::MyGraph) = codom(src(g)) # == codom(tgt(g))
   edges(g::MyGraph) = dom(src(g)) # == dom(tgt(g))
   ```
   
   Now let's test that it works!

   ```{julia}
   using Test

   s, t = FinFunction([1,1], 3), FinFunction([2,1], 3)
   g = MyGraph(s, t)
   
   @test vertices(g) == FinSet(3)
   @test edges(g) == FinSet(2)
   ```

:::

# Part 2

:::{.rmenv title="Exercise (Growing rabbits)"}
Implement the dynamical system

$$ \dot{R} = \alpha R $$

using `AlgebraicDynamics`.
:::

:::{.solenv}
Define the dynamical system as a resource sharer:

```{julia}
using AlgebraicDynamics

ṙ(r,p,t) = p.α * r
rabbit_growth = ContinuousResourceSharer{Float64}(1, ṙ)
```

Simulate and plot:

```{julia}
using LabelledArrays
using DifferentialEquations, Plots

u0 = [1.0]
params = LVector(α=0.3)
tspan = (0.0, 10.0)

prob = ODEProblem(rabbit_growth, u0, tspan, params)
sol = solve(prob, Tsit5())

plot(sol, title="Exponential growth of rabbit population",
     legend=false, xlabel="time", ylabel="population size")
```
:::

:::{.rmenv title="Exercise (UWDs as data structure)"}
a. Write a call to the `@relation` macro that constructs the shown UWD.
b. Construct the UWD manually using the API for UWDs or the lower-level API for acsets.
:::

:::{.solenv}
Using the `@relation` macro:

```{julia}
uwd = @relation (x,y,z) where (w,x,y,z) begin
  R(x,w)
  S(y,w)
  T(z,w)
end

to_graphviz(uwd, box_labels=:name, junction_labels=:variable)
```

Using the UWD API:

```{julia}
d = RelationDiagram(3) # Create diagram with 3 outer ports
add_junctions!(d, 4, variable=[:w,:x,:y,:z]) # Add four junctions
set_junction!(d, 1:3, 2:4, outer=true) # Set junctions of outer ports

for name in [:R, :S, :T]
  add_box!(d, 2, name=name) # Add box with two ports
end
for (i, box) in enumerate(boxes(d))
  set_junction!(d, (box, 1), i+1)
  set_junction!(d, (box, 2), 1)
end

using Test
@test d == uwd
```

The advantange of using the programmatic API is that this code is easily generalized to a function that creates a "star-shaped UWD" of any size. You might try implementing this function as a further exercise.
:::

:::{.rmenv title="Exercise (Graph traversal)"}
Implement a graph traversal algorithm, such as depth-first search or
breadth-first search, using the acsets API (`subpart`, `incident`).
:::

:::{.solenv}
A stack-based depth-first search algorithm:

```{julia}
#| output: false
using Catlab
using DataStructures: Stack

""" Depth-first search in graph `g` starting at vertex `v`

The function `f` is called at every vertex in the search path.
"""
function dfs(f::Function, g::ACSet, v::Int)
  seen = Set{Int}()
  next = Stack{Int}()
  push!(next, v)
  while !isempty(next)
    v = pop!(next)
    v ∈ seen && continue
    f(v)
    push!(seen, v)
    # Add all outgoing edges to the stack.
    for e in incident(g, v, :src)
      # Syntactic sugar: `g[e, :tgt] == subpart(g, e, :tgt)``
      push!(next, g[e, :tgt])
    end
  end
end
```

Traversal of a directed cycle, starting at the third vertex, yields the vertices
in the expected order.

```{julia}
g = cycle_graph(Graph, 6)
dfs(println, g, 3)
```

:::{.rmenv title="Exercise (Union-find)"}
Use the union-find data structure to find the connected components of a graph, by making `src(e)` and `tgt(e)` be in the same equivalence class for each edge `e`.
:::

:::{.solenv}
```{julia}
#| output: false
using Catlab
using DataStructures: IntDisjointSets, union!, find_root

""" Find connected components of a graph.

Returns a dictionary from the component roots to lists of vertices in each
component.
"""
function connected_components(g::HasGraph)
  sets = IntDisjointSets(nparts(g, :V))
  for e in parts(g, :E)
    union!(sets, g[e,:src], g[e,:tgt])
  end

  components = Dict{Int,Vector{Int}}()
  for v in parts(g, :V)
    component = get!(() -> Int[], components, find_root(sets, v))
    push!(component, v)
  end
  components
end
```

A graph with three components constructed as a coproduct of basic graphs:

```{julia}
g = path_graph(Graph, 3) ⊕ cycle_graph(Graph, 4) ⊕ star_graph(Graph, 4)

values(connected_components(g))
```

:::

## Part 3

:::
