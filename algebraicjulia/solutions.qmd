---
title: Solutions to Exercises
---

## Part 1

:::{.rmenv title="Exercise (Installation)"}
Follow the [quick start](quickstart) instructions to install Julia, a code editor, and the git version control system.
:::

:::{.solenv}
If you're stuck on setup, please ask an instructor or TA for help!
:::

:::{.rmenv title="Exercise (Hello World)"}
Get Julia to print "Hello World".
:::

:::{.solenv}
Output text with the `println` function.

```{julia}
println("Hello World!")
```

String concatentation in Julia uses the `*` symbol.

```{julia}
println("Hello" * " " * "World!")
```

Print everything in a vector by using broadcasting. To broadcast, append `.` to your function, and pass it something you can iterate over (like a vector). Or, use `map` or `foreach`.

```{julia}
# Both of these return a vector of `nothing`s:

# println.(["Hello", "World!"])
# map(println, ["Hello", "World!"])

# This one produces side effects only:
foreach(println, ["Hello", "World!"])
```

Perform string interpolation using `$`.

```{julia}
favorite_library = "AlgebraicDynamics.jl"

println("My favorite AlgebraicJulia package is $(favorite_library)!")
```
:::

:::{.rmenv title="Exercise (Package management)"}
Install a Julia package, such as `Catlab` or `AlgebraicDynamics`, using the [Julia package manager](https://docs.julialang.org/en/v1/stdlib/Pkg/).
:::

:::{.solenv}
From a Julia REPL, enter the package manager by typing `]`. Create a new project, which will organize the packages you're using for this workshop, by typing
`pkg> activate .`
Next, add Catlab to your project by typing
`pkg> add Catlab`
You should see a bunch of stuff happening, including precompilation of the Catlab code.

When that's finished, hit backspace to get out of the package manager and type
```julia
using Catlab
```
to load Catlab into your REPL session. To make sure it worked right, try something like
```julia
g = path_graph(Graph, 7)
```
to produce your first graph in Catlab!
:::


:::{.rmenv title="Exercise (Sharing is caring)"}
Fork and clone the [ACT2023Tutorial](https://github.com/AlgebraicJulia/ACT2023Tutorial) repository, make a change, commit it, and create a pull request.
:::

:::{.solenv}

1. Log into [github.com](https://github.com)
2. Navigate to [github.com/AlgebraicJulia/ACT2023Tutorials](https://github.com/AlgebraicJulia/ACT2023Tutorials)
3. By the top right of the page there click the "Fork" button to the left of the "Star" button.
4. On the next page click "Create fork", this will create a copy of the repository on your own GitHub account
5. Clone your fork (replacing `<user_name>` with your own GitHub username)
   ```sh
   git clone https://github.com/<user_name>/ACT2023Tutorials.git
   ```
6. Navigate into the solutions folder and create a new directory with your name (replacing `<your_name>` with your own name)
   ```sh
   cd ACT2023Tutorials/solutions
   mkdir <your_name>
   ```
7. Put some code in there!
   ```sh
   echo "print('Hello, World!')" > hello_world.jl
   ```
8. Stage, commit, and push your changes
   ```sh
   git add hello_world.jl
   git commit -m "Adding solutions for <your_name>"
   git push
   ```
9. Navigate to your fork on GitHub (replacing `<user_name>` with your GitHub username): `https://github.com/<user_name>/ACT2023Tutorials`
10. Click the "Pull requests" tab across the top of the page and click the "New pull request". This will automatically create a new pull request on the original repository from your fork
11. Click "Create pull request"
12. Put a short title and description and click "Create pull request"

:::

:::{.rmenv title="Exercise (Graphs)"}
Implement a graph data structure in Catlab either (a) using Catlab's support for C-sets (`@acset_type`) or (b) more directly, using finite sets (`FinSet`) and functions (`FinFunction`).
:::

:::{.solenv}

a. Graphs as C-sets:

   ```{julia}
   using Catlab

   @present SchGph(FreeSchema) begin
      V::Ob
      E::Ob
      src::Hom(E,V)
      tgt::Hom(E,V)
   end

   # Index the `src` and `tgt` functions for fast lookups of inverse images
   # using the `incident` function.
   @acset_type Gph(SchGph, index=[:src,:tgt])

   # An example graph
   g = @acset Gph begin
     V = 3
     E = 2
     src = [1,1]
     tgt = [2,1]
   end
   ```
   
   We use the name `Gph` to avoid a name conflict with Catlab's exported type
   `Graph`, but `Graph` is defined in Catlab in exactly the same way!
   
   The exported `Graph` type includes support for visualization using
   [Graphviz](https://graphviz.org/), which we can use to see what the above
   graph looks like:
   
   ```{julia}
   g = @acset Graph begin
     V = 3
     E = 2
     src = [1,1]
     tgt = [2,1]
   end
   
   to_graphviz(g, node_labels=true)
   ```
   
b. Using finite sets and functions:

   ```{julia}
   #| output: false
   # Catlab exports these generic functions. We import them explicitly so that
   # we can add new methods to them.
   import Catlab: src, tgt, vertices, edges
   
   struct MyGraph
     # We don't need fields for `E` and `V` since these are the domain and
     # codomain of `src` and `tgt`.
     src::FinFunction
     tgt::FinFunction

     function MyGraph(src::FinFunction, tgt::FinFunction)
       dom(src) == dom(tgt) || error("Source and target must have same domain")
       codom(src) == codom(tgt) || error("Source and target must have same codomain")
       new(src, tgt)
     end
   end

   # A few accessor functions. Our users shouldn't need to know the internal
   # layout of the fields in the struct!
   src(g::MyGraph) = g.src
   tgt(g::MyGraph) = g.tgt
   vertices(g::MyGraph) = codom(src(g)) # == codom(tgt(g))
   edges(g::MyGraph) = dom(src(g)) # == dom(tgt(g))
   ```
   
   Now let's test that it works!

   ```{julia}
   using Test

   s, t = FinFunction([1,1], 3), FinFunction([2,1], 3)
   g = MyGraph(s, t)
   
   @test vertices(g) == FinSet(3)
   @test edges(g) == FinSet(2)
   ```

:::

# Part 2

:::{.rmenv title="Exercise (Graph traversal)"}
Implement a graph traversal algorithm, such as depth-first search or
breadth-first search, using the acsets API (`subpart`, `incident`).
:::

:::{.solenv}
A stack-based depth-first search algorithm:

```{julia}
#| output: false
using Catlab
using DataStructures: Stack

""" Depth-first search in graph `g` starting at vertex `v`

The function `f` is called at every vertex in the search path.
"""
function dfs(f::Function, g::ACSet, v::Int)
  seen = falses(nparts(g, :V))
  next = Stack{Int}()
  push!(next, v)
  while !isempty(next)
    v = pop!(next)
    seen[v] && continue
    f(v)
    seen[v] = true
    # Add all outgoing edges to the stack.
    for e in incident(g, v, :src)
      # Syntactic sugar: `g[e, :tgt] == subpart(g, e, :tgt)``
      push!(next, g[e, :tgt])
    end
  end
end
```

Traversal of a directed cycle, starting at the third vertex, yields the vertices
in the expected order.

```{julia}
g = cycle_graph(Graph, 6)
dfs(println, g, 3)
```

:::
