[
  {
    "objectID": "exercises.html",
    "href": "exercises.html",
    "title": "Exercises",
    "section": "",
    "text": "The purpose of these exercises is to guide your efforts in learning AlgebraicJulia. Thus, some of these exercises are purposely underspecified; and for many, the answer is not as important as the process of getting to that answer.\nFor instance, in the first couple exercises, we ask you to install Julia and do some basic tasks. The difficult part here is not mathematical, these are exercises in computer systems administrations! Hopefully, everything goes smoothly with installation, but if not, also think of this as an exercise in how to debug computer systems, and don’t hesitate to ask the TAs or I for help.\nLater exercises include some questions about to design software; these too have very open-ended answers. Writing software is very much like doing mathematical research, in that as much or more of your time is spent thinking about what to prove as it is spent proving it. Applied to software, this translates to the fact that more of your time is spent in designing the architecture of programs than in implementing algorithms whose parameters and specifications are known in advance. In computational category theory, this is doubly so. So hopefully these exercises will get you started thinking about these questions, and perhaps you will come up with ideas and approaches that will be new to us!\nWe expect that you have some familiarity with some other programming language (though not necessarily Julia). But more importantly, we expect that you will use every resource at your disposal to work through these exercises.\nThe exercises are rated in difficulty from ★ (easiest) to ★ ★ ★ ★ ★ (open problem)."
  },
  {
    "objectID": "exercises.html#part-1",
    "href": "exercises.html#part-1",
    "title": "Exercises",
    "section": "Part 1",
    "text": "Part 1\nThis first part will be focused on getting familiar with Julia, and the AlgebraicJulia philosophy of doing category theory on the computer.\n\nFollow the instructions in the quick start to install Julia, a code editor, and git.\n\n\nIn my opinion, one of the biggest barriers to entry to software development for academics is how unintuitive version control is.\n\n\nGet Julia to print “Hello World”.\n\n\nWe can represent the objects and morphisms in the skeleton of \\(\\mathsf{FinSet}\\) using the following Julia structs.\nstruct FinSet\n  n::Int\nend\n\nstruct FinFunction\n  values::Vector{Int}\n  dom::FinSet\n  codom::FinSet\nend\n\nA, B = FinSet(3), FinSet(2)\nf = FinFunction([1,2,2], A, B)\nIf you aren’t familiar with structs in Julia, here’s the documentation.\nPut the above definitions in a file"
  },
  {
    "objectID": "exercises.html#part-2",
    "href": "exercises.html#part-2",
    "title": "Exercises",
    "section": "Part 2",
    "text": "Part 2"
  },
  {
    "objectID": "exercises.html#part-3",
    "href": "exercises.html#part-3",
    "title": "Exercises",
    "section": "Part 3",
    "text": "Part 3"
  },
  {
    "objectID": "presentation.html#category-theory-in-a-dynamic-language",
    "href": "presentation.html#category-theory-in-a-dynamic-language",
    "title": "ACT2023 AlgebraicJulia Tutorial",
    "section": "Category theory in a dynamic language",
    "text": "Category theory in a dynamic language\n\nIt’s not as cursed as you’d think.\n– Owen Lynch, 2023\n\n\nRoughly speaking, dynamic language is one where variables are not associated with types, only values. So the type associated to a variable is only known when that variable is associated with a value at runtime, and this can change as it is associated with different values.\nIn a static language, in contrast, one can determine the type of a variable without running the program, and the type of a variable does not change over time.\nWhen people typically think about doing category theory in a programming language, they think about the category where the objects are types in a statically typed programming language, and the morphisms are functions between them. This category is typically a cartesian closed category.\nHowever, this particular way of connecting category theory to computing is not the last word on computing and category theory. Applied Category Theory in particular gives rise to a lot of questions where the answer can be computed, and a-priori the most ergonomic and performant way to compute the answers to those questions is not necessarily via one of the existing programming languages (Haskell, Agda, Idris, etc.) whose type system forms a cartesian closed category.\nFor example:\n\nDatabases operations a la Spivak\nOpen dynamical systems\nString diagrams as combinatorial objects\n\nJulia of course is not the best language for all of the things that we do in it, because no language is “best”. But Julia has a combination of features that makes it quite well-suited for the job, in addition to a state-of-the-art ecosystem of modern numerical computing libraries."
  },
  {
    "objectID": "presentation.html#what-is-julia",
    "href": "presentation.html#what-is-julia",
    "title": "ACT2023 AlgebraicJulia Tutorial",
    "section": "What is Julia?",
    "text": "What is Julia?\nJulia is a"
  },
  {
    "objectID": "presentation.html#why-is-julia",
    "href": "presentation.html#why-is-julia",
    "title": "ACT2023 AlgebraicJulia Tutorial",
    "section": "Why is Julia?",
    "text": "Why is Julia?"
  },
  {
    "objectID": "presentation.html#how-is-julia",
    "href": "presentation.html#how-is-julia",
    "title": "ACT2023 AlgebraicJulia Tutorial",
    "section": "How is Julia?",
    "text": "How is Julia?"
  },
  {
    "objectID": "presentation.html#where-is-julia",
    "href": "presentation.html#where-is-julia",
    "title": "ACT2023 AlgebraicJulia Tutorial",
    "section": "Where is Julia?",
    "text": "Where is Julia?"
  },
  {
    "objectID": "presentation.html#bibliography",
    "href": "presentation.html#bibliography",
    "title": "ACT2023 AlgebraicJulia Tutorial",
    "section": "Bibliography",
    "text": "Bibliography\n\n\n\nback to main site | ACT2023 AlgebraicJulia Tutorial\n\n\n\nBaez, John C., and Kenny Courser. 2020. “Structured Cospans.” arXiv. https://doi.org/10.48550/arXiv.1911.04630.\n\n\nBrown, Kristopher, Tyler Hanks, and James Fairbanks. 2022. “Compositional Exploration of Combinatorial Scientific Models.” arXiv. https://doi.org/10.48550/arXiv.2206.08755.\n\n\nHalter, Micah, Evan Patterson, Andrew Baas, and James Fairbanks. 2020. “Compositional Scientific Computing with Catlab and SemanticModels.” arXiv. https://doi.org/10.48550/arXiv.2005.04831.\n\n\nLibkind, Sophie, Andrew Baas, Micah Halter, Evan Patterson, and James Fairbanks. 2022. “An Algebraic Framework for Structured Epidemic Modeling.” Philosophical Transactions of the Royal Society A: Mathematical, Physical and Engineering Sciences 380 (2233): 20210309. https://doi.org/10.1098/rsta.2021.0309.\n\n\nLibkind, Sophie, Andrew Baas, Evan Patterson, and James Fairbanks. 2022. “Operadic Modeling of Dynamical Systems: Mathematics and Computation.” Electronic Proceedings in Theoretical Computer Science 372 (November): 192–206. https://doi.org/10.4204/EPTCS.372.14.\n\n\nPatterson, Evan, Andrew Baas, Timothy Hosgood, and James Fairbanks. 2022. “A Diagrammatic View of Differential Equations in Physics.” Mathematics in Engineering 5 (2): 1–59. https://doi.org/10.3934/mine.2023036.\n\n\nPatterson, Evan, Owen Lynch, and James Fairbanks. 2022. “Categorical Data Structures for Technical Computing.” Compositionality 4 (December): 5. https://doi.org/10.32408/compositionality-4-5.\n\n\nVagner, Dmitry, David I. Spivak, and Eugene Lerman. 2015. “Algebras of Open Dynamical Systems on the Operad of Wiring Diagrams.” arXiv. https://doi.org/10.48550/arXiv.1408.1598."
  },
  {
    "objectID": "quickstart.html",
    "href": "quickstart.html",
    "title": "Quick Start",
    "section": "",
    "text": "Overview\nTo be able to complete most of the exercises, you will need the following:\n\nA text editor (for writing code), such as\n\nEmacs\nVim/Neovim\nVisual Studio Code\n\nJulia (for running code)\nGit (for sharing code), optionally with a wrapper to make it easier\n\nGitkraken\nmagit (if you use Emacs)\nlazygit\ngithub desktop\nbuilt in git support in vs code\n\n\nAll of these tools can be installed on Windows, macOS, and Linux. On this page you will find instructions for setting these tools up, and during the tutorial session, we will be around to help anyone with installation troubles."
  },
  {
    "objectID": "index.html",
    "href": "index.html",
    "title": "ACT2023 AlgebraicJulia Tutorial Session",
    "section": "",
    "text": "Welcome to the ACT2023 tutorial session on AlgebraicJulia, presented by Owen Lynch and assisted by\n\nKris Brown\nMicah Halter\nTyler Hanks\nLuke Morris"
  }
]